<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PythonGUI图形化界面详解</title>
      <link href="/2024/01/01/pythongui-tu-xing-hua-jie-mian-xiang-jie/"/>
      <url>/2024/01/01/pythongui-tu-xing-hua-jie-mian-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="0-简介"><a href="#0-简介" class="headerlink" title="0 简介"></a>0 简介</h1><p>话说你看到的软件是不是都是用图形化界面（Graphical User Interface, GUI）整出来的？</p><p>比如这个：</p><p><img src="/img/2023-12-29_19-37-52.png"></p><p>然鹅，再看看咱的“图形化界面”：</p><p><img src="/img/2023-12-29_19-40-06.png"></p><p>upd：这里的命令行界面连图形化界面都不是，应该叫文本用户界面（Text User Interface, TUI），不可以混淆！</p><p>根本不是一个等级的啊！于是，我们来用Python整一个真正的GUI吧！</p><h1 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1 安装环境"></a>1 安装环境</h1><blockquote><p>Tips：如果您已安装Python和一个另外的IDE，可以忽略此步骤。但如果后续发现有模块运行不了且代码、模块等正常，可以按照此步骤重新安装。</p></blockquote><p>见<a href="https://www.cnblogs.com/leo2011/p/17938782">这里</a></p><h1 id="2-easygui"><a href="#2-easygui" class="headerlink" title="2 easygui"></a>2 easygui</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install easygui</span><br></pre></td></tr></table></figure><p>在你的终端中运行这段代码。如果出现了下面的东西，那么就说明安装easygui成功啦（以后我介绍的模块除了特殊说明外，都要用类似的方法安装，就不在提了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Looking in indexes: https://mirrors.sustech.edu.cn/pypi/simple</span><br><span class="line">Collecting easygui</span><br><span class="line">  Using cached https://mirrors.sustech.edu.cn/pypi/packages/8e/a7/b276ff776533b423710a285c8168b52551cb2ab0855443131fdc7fd8c16f/easygui-0.98.3-py2.py3-none-any.whl (92 kB)</span><br><span class="line">Installing collected packages: easygui</span><br><span class="line">Successfully installed easygui-0.98.3</span><br></pre></td></tr></table></figure><p>然后，在你的IDE中新建个<code>.py</code>文件，输入这段代码，如果出现了下面这幅图，就算成功啦！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> easygui <span class="keyword">as</span> eg</span><br><span class="line">eg.msgbox(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/2023-12-29_22-44-36.png"></p><p>点掉下面的<code>OK</code>，窗口就会消失。</p><p>如果有问题，请核实一下下面的东西：</p><blockquote><p>Warning: easygui 是运行在 tkinter 上并拥有自身的事件循环，而 IDLE 也是 tkinter 写的一个应用程序并也拥有自身的事件循环。因此当两者同时运行的时候，有可能会发生冲突，且带来不可预测的结果。因此如果你发现你的 easygui 程序有这样的问题，请尝试在 IDLE 外去运行你的程序。</p></blockquote><p>其实就3句话：</p><p>不要用自带的IDLE！！！</p><p>不要用自带的IDLE！！！</p><p>不要用自带的IDLE！！！</p><p>如果没问题，那么，恭喜你，再次打开了新世界的大门！</p><p>接下来，就是对它的一顿研究了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg.msgbox(msg=<span class="string">&quot;A + B Problem&quot;</span>, title=<span class="string">&quot;Leo2011&quot;</span>, ok_button=<span class="string">&quot;I AK IOI!&quot;</span>)</span><br></pre></td></tr></table></figure><p>不出所料的话，应该是这样的：<br><img src="/img/2023-12-29_22-50-26.png"></p><p>看，我们用<code>title=&quot;Leo2011&quot;</code>把标题改成了”Leo2011”，用<code>ok_button=&quot;I AK IOI!&quot;</code>把下面的按钮改成了”I AK IOI!”。</p><p>这就msgbox能干的事了。</p><p>下面，咱来看另外的几个家伙：</p><ul><li><p>enterbox</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = eg.enterbox(<span class="string">&quot;欢迎您随便输入一堆东西&quot;</span>, title=tit)</span><br><span class="line">eg.msgbox(msg=<span class="string">&quot;您刚才输入了\n&quot;</span>+s, title=tit, ok_button=<span class="string">&quot;我知道了。&quot;</span>)</span><br></pre></td></tr></table></figure><p>  能弹出这么个框：<br>  <img src="/img/2023-12-29_22-59-52.png"></p></li></ul><p>框中可以随便输东西（只要你打得出来），输完了按回车或点<code>OK</code>（这个不能改）结束。如果你点了<code>Cancel</code>或直接关掉了这个框，会返回<code>None</code>（这不是一个字符串，是<code>Nonetype</code>，意思就是啥也没有）</p><ul><li><p>multenterbox</p><p>  有一堆enterbox在一个窗口里。</p></li><li><p>passwordbox</p><p>  跟enterbox一样，只不过用户视角中输入的字符只能看到“*”，跟输密码似的。</p></li><li><p>multpasswordbox</p><p>  有一堆passwordbox在一个窗口里。</p></li><li><p>ccbox</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = eg.ccbox(<span class="string">&quot;欢迎您随便选东西&quot;</span>, title=tit, choices=[<span class="string">&quot;[D]ebug&quot;</span>, <span class="string">&quot;C[t]j&quot;</span>])</span><br><span class="line">eg.msgbox(msg=<span class="string">&quot;您刚才输入了\n&quot;</span>+<span class="built_in">str</span>(s), title=tit, ok_button=<span class="string">&quot;我知道了。&quot;</span>)</span><br></pre></td></tr></table></figure><p>  []里的字符相当于快捷键，你按下这个键就会认为你选了这个选项。ccbox只能有两个选项（否则解释器会炸）。</p></li><li><p>boolbox&#x2F;ynbox</p><p>  同ccbox，不讲。</p></li><li><p>choicebox</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = eg.choicebox(<span class="string">&quot;欢迎您随便选东西&quot;</span>, title=tit, choices=[<span class="string">&quot;Debug&quot;</span>, <span class="string">&quot;Ctj&quot;</span>, <span class="string">&quot;AC!&quot;</span>])</span><br></pre></td></tr></table></figure><p> UI会变成这样：<br> <img src="/img/2023-12-30_17-13-55.png"><br> 刚才的快捷键就只能是首字母了。choicebox可以有多个选项，但只能选一个（默认是第一个）。</p></li><li><p>buttonbox</p><p>  同choicebox，不讲。</p></li><li><p>indexbox</p><p>  跟choicebox一样，只不过choicebox会返回你选中的文本，而indexbox会返回你选中的那货在你的选项列表里的下标。</p></li><li><p>multchoicebox</p><p>  <del>有一堆choicebox在一个窗口里？</del><br>  这次easygui不按套路出牌了，界面长这样：<br>  <img src="/img/2023-12-30_17-19-34.png"><br>  <code>Select All</code>就是全选，<code>Clear All</code>就是全不选，剩下两个老朋友了。<br>  返回值是这样的<code>[&#39;Debug&#39;, &#39;AC!&#39;]</code>。它会按你选中的选项在选项列表里的相对位置排成一个新列表。</p></li><li><p>integerbox</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = eg.integerbox(msg=<span class="string">&quot;请输入一个数&quot;</span>, title=tit, default=<span class="number">5</span>, lowerbound=<span class="number">3</span>, upperbound=<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>  指定你输入一个在<code>lowerbound</code>和<code>upperbound</code>之间的整数，默认为<code>default</code>。如果不在区间内了会让你重新输入。</p></li><li><p>egdemo</p><p>  easygui所有函数的效果演示。</p></li></ul><p>eaysgui确实很easy！</p><h1 id="3-turtle"><a href="#3-turtle" class="headerlink" title="3 turtle"></a>3 turtle</h1><blockquote><p>Tips:实测Python turtle的不同版本在不同平台上可能会有所不同，本文以Windows 11 + Python 3.12.1为准。</p></blockquote><p>turtle库（人送绰号“海龟绘图”）是Python的内置库，安装了Python就可以直接用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line">t.write(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">t.done()  <span class="comment"># 这一行必须要有，否则你是看不见你的效果的</span></span><br></pre></td></tr></table></figure><p>这就是你的第一个turtle程序了！</p><p>下面，还是来介绍几个基本函数的使用：</p><ul><li><p>home</p><p>  木有参数。回到原点(0, 0)，也就是屏幕正中央的起始位置（这在你画图画懵13的时候很有用）。</p></li><li><p>forward&#x2F;fd</p><p>  1个参数 $k$，表示你想要让这个画笔沿笔头方向前进 $k$ 个像素。如<code>fd(1000)</code>即让画笔从当前位置前进1000个像素。</p></li><li><p>backward&#x2F;bk&#x2F;back</p><p>  1个参数 $k$，相当于<code>fd(-k)</code>，即沿笔头方向后退 $k$ 步。</p></li><li><p>left&#x2F;lt</p><p>  1个参数 $k$，表示你想让画笔左转 $k^\circ$。</p></li><li><p>right&#x2F;rt</p><p>  1个参数 $k$， 表示你想让画笔右转 $k^\circ$。</p></li><li><p>goto</p><p>  2个参数 $x, y$，表示将画笔直线移动到 $(x, y)$的位置。如果画笔还没被抬起来，就会把轨迹画下来。</p></li><li><p>circle</p><p>  用来画圆的（这是空心的）。参数最多3个：$r, e, s$， $r$ 表示要画的圆的半径（必须要写），$e$ 表示圆心角度数（默认为整个圆），$s$ 表示要画的正多边形边数（不写会自动确定）。这里解释一下，电脑上画圆不太现实，都是用正 $n$ 边形（这个 $n$ 一般不小）模拟出来的，所以这个函数即可用来画圆也可以用来画正多边形。</p></li><li><p>dot</p><p>  也是画一个圆。最多两个参数：$d$ 和 color。 $d$ 指要画的圆的直径，color是一个字符串，表示要画的圆的颜色。与circle不同，dot画的圆是实心的，而circle默认情况下是空心的。</p></li><li><p>penup&#x2F;up&#x2F;pu</p><p>  抬起笔，此后在落下笔之前所有的操作都不会留下痕迹。</p></li><li><p>pendown&#x2F;pd&#x2F;down</p><p>  落下笔。一般可以这么使：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">x, y</span>):</span><br><span class="line">    t.pu()</span><br><span class="line">    t.goto(x, y)</span><br><span class="line">    t.pd()</span><br></pre></td></tr></table></figure></li><li><p>speed</p><p>  设置速度的，有一个参数 $v$。你在用的时候，应保证 $0 \le v \le 10$。一般情况下，$v$ 是个整数，且越大代表越快，但也有例外：</p><table><thead><tr><th align="center">$v$ 的值</th><th align="center">速度</th></tr></thead><tbody><tr><td align="center">0或”fastest”</td><td align="center">最快</td></tr><tr><td align="center">10或”fast”</td><td align="center">快</td></tr><tr><td align="center">6或”normal”</td><td align="center">正常（默认）</td></tr><tr><td align="center">3或”slow”</td><td align="center">慢</td></tr><tr><td align="center">1或”slowest”</td><td align="center">最慢</td></tr></tbody></table></li><li><p>pensize&#x2F;width</p><p>  一个参数 $w$，表示画笔粗细。</p></li><li><p>pencolor</p><p>  可以没有参数，此时返回画笔颜色（默认是黑色 ），也可以给出参数，此时是设置颜色。</p><p>  有以下几种设置模式：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t.pencolor(<span class="string">&quot;red&quot;</span>)  <span class="comment"># 设置为红色</span></span><br><span class="line">t.pencolor(<span class="string">&quot;#abcde&quot;</span>)  <span class="comment"># 设置为十六进制编码为“abcde”的颜色</span></span><br><span class="line">t.pencolor((<span class="number">1</span>, <span class="number">255</span>, <span class="number">255</span>))  <span class="comment"># 设置为青色。三个数值表示RGB编码</span></span><br><span class="line">t.pencolor(<span class="number">1</span>, <span class="number">255</span>, <span class="number">255</span>)  <span class="comment"># 同上，只不过上面传过去的是一个元组。</span></span><br></pre></td></tr></table></figure></li><li><p>fiilcolor</p><p>  填充颜色，同上。</p></li><li><p>color</p><p>  两个都设置了，可以填写1~2组参数。1组就是设置成一样的，两组就是先pencolor再fillcolor。</p></li><li><p>bgcolor</p><p>  背景颜色，参数同pencolor。</p></li><li><p>bgpic</p><p>  背景图片，需要给一个字符串表示背景图片位置。如果是”nopic”就是删除背景图片。</p></li><li><p>begin_fill</p><p>  记录一下，准备填充。</p></li><li><p>end_fill</p><p>  把上次begin_fill以后画的东西填充成fillcolor。</p></li><li><p>write</p><p>  主要有2个参数，文字和设置。可以把文字设置成属性后写上去，如开头的例子。</p></li><li><p>hideturtle&#x2F;ht</p><p>  隐藏画笔，能加速。</p></li><li><p>showturtle&#x2F;st</p><p>  显示画笔。</p></li><li><p>shape</p><p>  海龟绘图，海龟在哪儿呢？</p><p>  就是这么设置的。</p><p>  给定一个参数，它会自动把海龟调整成对应的形状。</p><p>  支持以下形状：</p><ul><li>“arrow”</li><li>“turtle”</li><li>“square”</li><li>“triangle”</li><li>“classic”</li></ul><p>  可以自己去试一试~</p></li><li><p>stamp</p><p>  把画笔印在当前位置，即在那个位置留下海龟的形状。</p></li></ul><p>turtle库就先介绍这些，不少了。自个儿试着画几张图去吧！</p><p>老规矩，有问题的欢迎私信联系我。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python环境安装与配置</title>
      <link href="/2024/01/01/python-huan-jing-an-zhuang-yu-pei-zhi/"/>
      <url>/2024/01/01/python-huan-jing-an-zhuang-yu-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="0安装Python"><a href="#0安装Python" class="headerlink" title="0安装Python"></a>0安装Python</h1><h2 id="0-0-下载安装Python"><a href="#0-0-下载安装Python" class="headerlink" title="0.0 下载安装Python"></a>0.0 下载安装Python</h2><p>要用Python，那肯定得先装个Python呐！</p><p>先把<a href="https://www.python.org/">Python官网</a>扒出来。访问速度一般不咋滴，请耐心等待~</p><p>如果正常，应该能出来个这个：<img src="/img/2023-12-29_20-39-34.png"></p><p><del>TMD我等了半天出来个我不认识的全英版本？</del></p><p><del>是的，就是这样的。</del></p><p>没事，我帮你翻译。选Downloads，鼠标在上面停留一会，会出现一个列表。直接选你用的系统（Win就选Windows，macOS就是macOS，Linux的……<del>自己找教程去吧，官方大概率没有</del>可以去Other Platforms瞅一瞅，没有就去问度娘吧），然后如下操作（macOS的会有一个<code>universal2 installer</code>，下载后打开，按指示操作就可以了）。</p><p><img src="/img/2023-12-29_20-49-55.png"></p><p>看图操作就好。下载可能比（fei）较（chang）慢，导入迅雷之类的下载器下载就好。</p><p>下载下来当然要打开啦（废话），正常情况下如图：</p><p><img src="/img/2023-12-29_21-32-31.png"></p><p>勾了 <code>Add python.exe to PATH</code>选项后一键安装就可以了。</p><p>然后静静地等着它安装。</p><p>安装的同时，可以去隔壁<a href="https://www.jetbrains.com.cn/">JetBrains官网</a>看看，这理由待会要用的IDE——Pycharm。</p><p>安装完后，按win + r，输入cmd，在弹出的窗口中输入python（如果是Linux&#x2F;macOS，因为这两者系统中内置一个Python的2.x版本，你需要做的是在终端中输入python3，相应地，后面的pip也要替换成pip3)，如果结果如图，那么恭喜你，Python安装成功（请注意！如果你没勾 <code>Add python.exe to PATH</code>这个选项，那么你电脑是查不到的！这种情况下需要你配置一下环境变量，每个版本的Win都不太一样，自己度娘去，实在不行重装吧……）！</p><p><img src="/img/2023-12-29_21-47-25.png"></p><h2 id="0-1-配置pip"><a href="#0-1-配置pip" class="headerlink" title="0.1 配置pip"></a>0.1 配置pip</h2><p>下一步，是配置pip。pip是用来管理外部库的，类似应用宝。pip默认的下载地址在国外，链接可能会TLE，需要配置一下。</p><h3 id="0-1-0-Linux-macOS用户："><a href="#0-1-0-Linux-macOS用户：" class="headerlink" title="0.1.0 Linux&#x2F;macOS用户："></a>0.1.0 Linux&#x2F;macOS用户：</h3><p>打开配置文件 <code>~/.pip/pip.conf</code>（不存在就创建），修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p>这里，<code>https://pypi.tuna.tsinghua.edu.cn/simple</code>是清华的镜像站，除了清华的，常用的还有：</p><table><thead><tr><th align="center">名称</th><th align="center">网站</th></tr></thead><tbody><tr><td align="center">南科大镜像源</td><td align="center"><a href="https://mirrors.sustech.edu.cn/pypi/web/simple">https://mirrors.sustech.edu.cn/pypi/web/simple</a></td></tr><tr><td align="center">阿里云镜像站</td><td align="center"><a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></td></tr><tr><td align="center">豆瓣镜像站</td><td align="center"><a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></td></tr><tr><td align="center">中科大镜像站</td><td align="center"><a href="https://pypi.mirrors.ustc.edu.cn/simple"> https://pypi.mirrors.ustc.edu.cn/simple</a></td></tr></tbody></table><h3 id="0-1-1-Windows用户"><a href="#0-1-1-Windows用户" class="headerlink" title="0.1.1 Windows用户"></a>0.1.1 Windows用户</h3><p>conf文件在<code>C:\Users\xx\pip</code>（xx是你用户名），其它的照抄Linux&#x2F;macOS的即可。</p><h2 id="0-2-升级turtle库"><a href="#0-2-升级turtle库" class="headerlink" title="0.2 升级turtle库"></a>0.2 升级turtle库</h2><p>这个步骤不是必须的，但很推荐操作。</p><p>现在你终端中跑一下这行代码：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install turtle <span class="literal">--upgrade</span> turtle</span><br></pre></td></tr></table></figure><p>肯定会炸。翻到上面以<code>Using cached xxx (xxkB)</code>开头的那玩意，中间的部分是一个链接，用浏览器打开，会自动下载下来。 </p><p>跑到下载目录，解压压缩包，找到setup.py，用记事本或者其它任何能编辑文本的东西打开（如果你装了下面的PyCharm，也可以用它）。找到第40行，更改成下面的样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> (ValueError, ve):</span><br></pre></td></tr></table></figure><p>保存，在终端中切到这个目录，运行以下代码：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="literal">-e</span> turtle<span class="literal">-0</span>.<span class="number">0.2</span></span><br></pre></td></tr></table></figure><p>现在应该就成功啦！</p><h1 id="1-安装PyCharm"><a href="#1-安装PyCharm" class="headerlink" title="1 安装PyCharm"></a>1 安装PyCharm</h1><p>这样Python就整完了，安装PyCharm去（当然，如果你愿意用VSCode、Sublime之类的其它工具写代码，我也不拦着你，但切记不要用自带的IDLE写，原因嘛<a href="https://www.cnblogs.com/leo2011/p/17938779">这里</a>有讲）。</p><p><a href="https://www.jetbrains.com.cn/pycharm/download/?section=windows">到这里</a>，把页面拉到底部，下载Community Edition就可以了（Professional Edition是付费的，而Community是免费的）。这次安装包是中文的，按指示操作就好。</p><p>打开PyCharm，会出来一个<code>JETBRAINS COMMUNITY EDITION TERMS</code>，直接点下面的勾后continue就好。</p><p>然后的界面中，点击<code>New Project</code>（新建一个项目，不建就没法使PyCharm），在新的窗口中如图配置，配置好后点Create就好了。</p><p><img src="/img/2023-12-29_22-34-21.png"></p><p>配置好后，就可以愉快的享受被誉为“宇宙最强PythonIDE”的PyCharm了！</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于三目运算符，你需要知道的所有</title>
      <link href="/2024/01/01/guan-yu-san-mu-yun-suan-fu-ni-xu-yao-zhi-dao-de-suo-you/"/>
      <url>/2024/01/01/guan-yu-san-mu-yun-suan-fu-ni-xu-yao-zhi-dao-de-suo-you/</url>
      
        <content type="html"><![CDATA[<p>if…else语句常写吧？</p><p>But，你会不会觉得：</p><p>写if…else？ 烦死了！</p><p>写switch？就俩我写啥……</p><p>于是，又一个C艹利器——三目运算符诞生啦！</p><p>先上代码：</p><p><code>mn = (a &lt; b) ? a : b; /* 其中，? :为三目运算符，一般为“结果保存值 = 条件 ? 结果A : 结果B*/</code></p><p>意思即：如果a &lt; b，那么mn &#x3D; a，否则mn &#x3D; b</p><p>那不就是if…else吗！</p><p>不，如果你用if…else，那么代码会变成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b)</span><br><span class="line">mn = a;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">mn = b;</span><br></pre></td></tr></table></figure><p>不仅变长了，而且，三目运算符是个运算符，它可以被塞进别的语句（写 DFS 或 DP 的时候可能会用到）里面！</p><p>最后，说一下性能排名。三目运算符作为运算，速度最快，但也有很大的限制（必须要有1个变量给赋值）。而switch和if…else不相上下，但是3个以上语句时，switch不仅更方便，还更快哟。</p><p>但if…else也不是一无是处，像浮点数这种你还真得用if…else是不？</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> “你需要知道的所有”系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C艹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于__int128和short，你需要知道的所有</title>
      <link href="/2024/01/01/guan-yu-int128-he-short-ni-xu-yao-zhi-dao-de-suo-you/"/>
      <url>/2024/01/01/guan-yu-int128-he-short-ni-xu-yao-zhi-dao-de-suo-you/</url>
      
        <content type="html"><![CDATA[<p>高精度大家都认识吧？</p><p>但是，高精度这货是真滴长……</p><p>于是，人们又发明出了一个东西 __int128！</p><p>__int128（注意前面有2个下划线）嘛，把特点写脸上了：占用128位，也就是16个字节。储存范围，自然也是占用64位的long long的2倍。换算一下，能存三十多近四十位。基本上可以代替部分高精度了。</p><p>那__int128这么NB，咋就不能被广泛使用呢（好多教材没教这个对不）？</p><p>因为它缺陷也很多：</p><ol><li>不通用。__int128并没有在任何一个C艹标准中严格定义 ，所以目前它只是GCC系列编译器的专属（NOI Linux恰好也用的是GCC，所以__int128可用。然鹅，使用Visual Studio的同志们，你们用的编译器一般是MSVC，是不支持的）。目前测试，只在Linux系统下能够正常使用（好在大部分地区比赛、评测均已切换至NOI Linux 2.0了）。</li><li>不方便。__{int128}目前看来是不支持直接读入、输出的。管你是cin、cout、scanf还是printf，都甭想输入一个__int128类型的数据。于是它输入得用string输入字符后$\times 10 +$尾数，输出得数位分解。</li><li>空间大，速度慢。 __int128占用了16个字节来存，MLE的风险显著增加。空间大速度还慢。你想啊，人家int才32位，64位的CPU一次处理俩；你128位，64位的CPU两次处理1个，不得慢死（TLE风险增加）……</li></ol><p>不过，为了让大家多掌握（pian）亿点东（fen）西，下面给出使用__int128时的基本框架。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        板子    </div>    <div class='spoiler-content'>        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log printf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">__int128 n;</span><br><span class="line"></span><br><span class="line"><span class="function">__int128 <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">__int128 x = <span class="number">0</span>; <span class="comment">// 虽然限制那么多，但咱赋个值总还是可以的吧…… </span></span><br><span class="line">    <span class="type">int</span> w = <span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; </span><br><span class="line">    w |= ch == <span class="string">&#x27;-&#x27;</span>; ch = <span class="built_in">getchar</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) </span><br><span class="line">    x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(__int128 x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        x *= <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line"><span class="built_in">output</span>(x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);  <span class="comment">// 众所周知这货只能搞四则运算，输出还请数位分解一下（其实就是快读快写）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  <span class="comment">// 你变量全用__int128我也不拦着你，但永远记住main函数不开int（好吧用signed也行）会CE的哈 </span></span><br><span class="line">n = <span class="built_in">reader</span>();</span><br><span class="line"><span class="comment">// 请自行操作</span></span><br><span class="line"><span class="built_in">output</span>(n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    </div></div><hr><p>说了这么半天慢的太吓人的__int128，那有木有一个特快的，比如说16位2个字节的哪种？<br>还真有，而且这个槽点就没那么多了。它就是——short！</p><p>short这玩意儿可比__int128强多了。它是通用的，也是可以直接读入、输出的（scanf和printf统一用“%hd”）。</p><p>那为啥它用的也不多呢？</p><p>因为它太省内存了，你说它就$2^{15} - 1$(不到4万）的存储范围能存个啥？</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> “你需要知道的所有”系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C艹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于auto，你须要知道的所有</title>
      <link href="/2024/01/01/guan-yu-auto-ni-xu-yao-zhi-dao-de-suo-you/"/>
      <url>/2024/01/01/guan-yu-auto-ni-xu-yao-zhi-dao-de-suo-you/</url>
      
        <content type="html"><![CDATA[<p>话说咱写 STL 的时候经常会要写迭代器，大概是这么一大串东西：</p><p><code>vector&lt;int&gt;::iterator iter = data.begin(); </code></p><p>好烦啊！而且，iterator 这个单词容易写错（CE：走好不送）……</p><p>于是，在 C 艹 11标准中，C 艹开发者发明了一个超级好用的东西：auto!</p><p>auto 这货类似于 Python 定义变量，会自动确定它的类型！</p><p>如：</p><p><code>auto a = 3; // a为int类型</code></p><p><code>auto b = a + 0.1;  // b为double类型</code></p><p>好爽哦有木有！</p><p>于是，开头的那段代码就可以写成这德行：</p><p><code>auto iter = data.begin();</code></p><p>你以为这就结束了？不，还有！</p><p>咱还能这么玩：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : data) &#123;  <span class="comment">// 不用auto写也行，只不过auto较简便</span></span><br><span class="line">    <span class="comment">// 正常写，i是普通的迭代器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过需要注意几点：</p><ol><li><p>auto 和 for 里用冒号的写法和 to_string 函数一样，都是C 艹 11的新特性，在Dev-C 艹中需要单独设置（否则直接炸裂）</p></li><li><p>比赛时采用 C 艹 14 标准，可放心使用</p></li><li><p>auto 因为要自动判断类型，运行速度会略慢一丁点，不过差距大概就是 scanf 和 cin 那点，一般 €€£ 不会在这点上卡常的(ps：据说 €€£ 在敛财将评测机由“老爷机”置换为“少爷机”，传闻新评测机能够在 1 秒内 AC(10^5 \times  10^5)的数据。但只是传言！现在还没有那么快！老老实实把代码时间复杂度降下来吧)……</p></li><li><p>别尝试 auto 一个数组，否则大概是这个场景：</p><p>你： <code>auto arr[10086];</code></p><p>编译器：<code>这踏马谁知道arr这货是啥类型啊……</code></p><p>Python ：<code>我咋可以呢？</code></p><p>编译器：<code>废话你啥都能存进去……</code></p><p>评测组件：<code>Compile Error！</code></p><p>€€£ 砖家组：<code>唉，又一个爆0了的……</code></p><p>到时候别怪我没提醒你啊……</p></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> “你需要知道的所有”系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C艹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于switch，你须要知道的所有</title>
      <link href="/2024/01/01/guan-yu-switch-ni-xu-yao-zhi-dao-de-suo-you/"/>
      <url>/2024/01/01/guan-yu-switch-ni-xu-yao-zhi-dao-de-suo-you/</url>
      
        <content type="html"><![CDATA[<p>话说写代码时要写 1 吨 if 的题你们有木有遇到？</p><p>比如<a href="https://wonderland.run/p/T1347">这道题</a>。6 个操作要写 6 个 if！那么你的代码可能会成这德行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 一顿操作猛如虎</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 一顿操作猛如虎</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">// 一顿操作猛如虎</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line"><span class="comment">// 一顿操作猛如虎</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="comment">// 一顿操作猛如虎</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//一顿操作猛如虎</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>坑*啊！一个这写 20 多行……</p><p>于是，人们发明了这个东西：switch！</p><p>switch 这玩意儿需要你给它 1 个数，它会自己判断。</p><p>格式大概是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (op) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :  <span class="comment">/*一顿操作猛如虎*/</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> :  <span class="comment">/*一顿操作猛如虎*/</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> :  <span class="comment">/*一顿操作猛如虎*/</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> :  <span class="comment">/*一顿操作猛如虎*/</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span> :  <span class="comment">/*一顿操作猛如虎*/</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span> :  <span class="comment">/*一顿操作猛如虎*/</span> <span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">case</span> <span class="number">10086</span>: <span class="comment">/*一顿操作猛如虎*/</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span> : <span class="comment">/*一顿操作猛如虎*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>咱来解读一下这货咋跑的：</p><p>先进去，op 是几就进哪个 case（与位置无关），执行里面的操作。注意case 语句后面的操作无论有几个语句都不用像 if 或循环那样写个花括号括起来。最后，如果你认为到此为止了，那么写个“break”结束。如果你不写“break”，那么它会自动执行下一个语句（可以是 case，也可以是 default）</p><p>如果哪个 case 都不对应呢？那么这个时候就进了 default。default 已经是默认一波操作了，不需要 break 了。</p><p>明白了不？</p><p>那么用 switch 语句改写上面那段代码就会变成这德行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (op) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :  <span class="comment">/*一顿操作猛如虎*/</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> :  <span class="comment">/*一顿操作猛如虎*/</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> :  <span class="comment">/*一顿操作猛如虎*/</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> :  <span class="comment">/*一顿操作猛如虎*/</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span> :  <span class="comment">/*一顿操作猛如虎*/</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span> :  <span class="comment">/*一顿操作猛如虎*/</span> <span class="keyword">break</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>是不是清爽了好多？</p><hr><p>Q &amp; A:</p><ol><li><p>case 里的 break; 还能结束循环吗？</p><p>不能，只能结束该 switch 语句。</p></li><li><p>你最后的那段代码没有 default 哎……</p><p>这货本来就是默认操作，可写可不写。就像你也写过1吨不带 else 的 if 一样……</p></li><li><p>default 只能写在最后嘛？</p><p>你爱写哪儿写哪儿，反正能走 case 的都先走 case 了。只不过一般会写在最后。</p></li><li><p>switch (op) 中的 op 可以是哪几种类型呢？</p><p>一般都是整数，有时也会用 char。但你千万别用浮点数（浮点数都敢枚举，疯了？这得枚举到猴年马月去……为了给你续命，正常的编译器都会直接CE）。</p></li><li><p>case里的东西只能写在 1 行里弄得我码风都乱了……</p><p>不是，这 TM 谁告诉你只能写在 1 行里的？你要是愿意可以写 10086w 行，反正都不用加花括号。写在 1 行里只是为了方便阅读……</p></li><li><p>能嵌套吗？</p><p>当然可以，switch&#x3D; 特殊的 if 语句，你 if 能嵌套 switch 咋就不行了？</p></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> “你需要知道的所有”系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C艹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于类，你须要知道的所有</title>
      <link href="/2024/01/01/guan-yu-lei-ni-xu-yao-zhi-dao-de-suo-you/"/>
      <url>/2024/01/01/guan-yu-lei-ni-xu-yao-zhi-dao-de-suo-you/</url>
      
        <content type="html"><![CDATA[<p>众所周知，Python是一种面向对象的语言，而C不是。</p><p>为啥呢？</p><p>因为Python引入了Class!</p><p>那都说C++也是面向对象的语言，C++有Class吗？</p><p>有！跟结构体差不多！</p><p>例如，下面这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">OIer</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果改用Class，就是这个样子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OIer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> age; <span class="comment">// 这里的内容我们叫属性</span></span><br><span class="line">        string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>咱来解释一下有啥变化。其实就一个：Public（除了这点，Class和Struct没啥区别）。这是因为每一种面向对象语言都有要对其成员进行保护的需求。Class这货默认是Private（你可以理解为要单独写访问函数才能访问，否则 <strong>CE</strong>，不过写工程的时候为保证数据安全，比较常用），要在前面加上<code>public:</code>才能正常访问。</p><p>访问函数咋写？</p><p>写成这样就行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OIer</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">haveAge</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">haveName</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">            name = s;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;Leo2011; <span class="comment">// 在这里，Leo2011就是一个对象</span></span><br></pre></td></tr></table></figure><p>好吧，挺长的。因此我们一般在数据简单（比如做题）的情况下用结构体，复杂的情况下（比如写能赚$的程序的时候）用类。</p><p>C++对Private是限制的非常死的，不用访问函数，外面，乃至包括他的子类，都无法访问（这点要夸一下C++，Python中设计了一个“强制访问”，可以越过这项检查，C++相比之下要安全一点），试图访问private里的东西就跟改变一个前面加了const修饰的常量一样，会CE！</p><p>那啥是子类啊？</p><p>举个栗子！</p><p>我们，既属于”OIer”，又属于”Student”，显然OIer都是学生（不然那叫教练），所以”OIer”就是”Student”的子类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">win</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I AK IELTS\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OIer</span> <span class="keyword">public</span>: Student&#123; <span class="comment">// 这里是public继承</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    我们一般管OIer叫派生类或子类，Student叫基类或父类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">haveAge</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">haveName</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">            name = s;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><del>TMD</del> 这Protected又是个啥啊</p><p>这个比较特殊，只能在子类和基类访问。</p><p>具体权限如下表（public继承），请务必要分清：</p><table><thead><tr><th align="center">类型&#x2F;位置</th><th align="center">基类</th><th align="center">派生类</th><th align="center">外部</th></tr></thead><tbody><tr><td align="center">Public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Protected</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">Private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p>protected&#x2F;private继承会把public和protected在子类中变为对应的级别。</p><p>接下来！我要讲个很重要的东西，那就是——<strong>类的多态</strong></p><p>啥叫多态呢？看这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">win</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I AK IELTS\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OIer</span> <span class="keyword">public</span>: Student&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">win</span><span class="params">()</span> </span>&#123;  <span class="comment">// 这个地方也叫重写win函数，重写后的函数名字和参数都是相同的，所以这里既有多态也有重写。不同就没有重写了。当然，父类中用private声明的东西访问都访问不了，重写是不可能滴。</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;| /-\|&lt; |o|!!!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">haveAge</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">haveName</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">            name = s;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，OIer 类和 Student 类都有一个 win 函数，但它们的内容是不同的。这就是多态。</p><p>还有另一个东西：重载</p><p>一般是这德行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> OIer &amp;cmp) <span class="type">const</span> &#123;  <span class="comment">// OIer是类的名称，其它照抄就好</span></span><br><span class="line">    <span class="keyword">return</span> a &lt; cmp. a;  <span class="comment">// sort的比较函数咋写的你就咋写</span></span><br><span class="line">    <span class="comment">/*return this-&gt;a &lt; cmp.a*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，”this-&gt;”是一个指向自己的特殊指针。不过在类当中，默认都是自己，写和不写没啥区别。</p><p>!&gt; <strong>请注意，以下运算符不可重载</strong>：</p><ul><li><code>.</code> ：成员访问运算符</li><li><code> .*</code>, <code>-&gt;*</code>：成员指针访问运算符</li><li><code>::</code>：域运算符</li><li><code>sizeof</code>：长度运算符</li><li><code> ?</code>：条件运算符</li><li><code>#</code>： 预处理符号</li></ul><p>!&gt; <strong>请注意，不允许通过重载定义新的运算符</strong></p><p>这种情况下，重载和多态的区别是，重载的内容来自 C++，多态的内容来自父类。</p><p>不过还有一种函数重载，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>  f)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c[])</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*假设现在在main函数内*/</span></span><br><span class="line">printData pd;</span><br><span class="line"><span class="comment">// 输出整数</span></span><br><span class="line">pd.<span class="built_in">print</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 输出浮点数</span></span><br><span class="line">pd.<span class="built_in">print</span>(<span class="number">500.263</span>);</span><br><span class="line"><span class="comment">// 输出字符串</span></span><br><span class="line"><span class="type">char</span> c[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">pd.<span class="built_in">print</span>(c);</span><br></pre></td></tr></table></figure><p>这里，对于不同的类型调用了不同的 print 函数，也就是函数重载了。但请注意，如果指示返回值不同，参数列表和名称相同也不构成重载。</p><p>最后，讲一下构造函数。</p><p>默认情况下，在你定义了对象但是又没有给它的属性赋值的时候，它的值就是全局变量时候的默认值。例如整数就是 0，字符串就是空，等等。</p><p>但有的时候，我们想要有一种默认情况，就会用到构造函数。<strong>构造函数不负责构造对象，只负责初始化对象</strong></p><p>咋写？</p><p>写成这样就行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面定义了 1 个包含 _year, _month 和 _day 的类 Date</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day) &#123;  <span class="comment">// 构造函数名=类名，注意构造函数和待会儿要讲的析构函数都不能有返回值定义，即不能写bool Date或void Date作为Date类的构造函数定义</span></span><br><span class="line">_year = year;</span><br><span class="line">_month = month;</span><br><span class="line">_day = day;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* main函数内 */</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2020</span>, <span class="number">4</span>, <span class="number">27</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>需要注意的是，写了构造函数后不给构造函数传足够的参数会 CE， 比如你不能写 <code>Date d;</code> 或 <code>Date d(3, 3);</code>，但是你也可以重载，来应付多种情况。</p><p>类似的还有析构函数，跟构造函数类似，只不过它是在对象被销毁（比如程序结束）的时候自动跑的，跟构造函数差不多，就不细讲了。唯一的区别就是析构函数在定义前要加一个<code>~</code></p><p>下面是个大家伙：类的嵌套！</p><p>啥意思？</p><p>还是看Code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">place</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    &#125;nodePlace;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* main函数内 */</span></span><br><span class="line">node nde;</span><br><span class="line">nde::place = &#123;<span class="number">3</span>, <span class="number">5</span>&#125;; </span><br><span class="line"><span class="comment">/* 与</span></span><br><span class="line"><span class="comment">  nde::place.x = 3;</span></span><br><span class="line"><span class="comment">  nde::place.y = 5;</span></span><br><span class="line"><span class="comment"> 等价 */</span></span><br><span class="line">nde::place.w = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>上面这段代码中，你在node类中新定义了一个place类，那么你就得先定义一个node类的对象（比如nde），然后通过<code>nde::place</code>的方式访问。</p><p>upd：<del>好吧我又来更新了</del>，这次讲一讲typedef。</p><p>用法也很简单:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="comment">/*1t代码*/</span></span><br><span class="line">&#125;mangaer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Person PM;</span><br></pre></td></tr></table></figure><p>这段代码相当于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="comment">/*代码*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Person manager;</span><br><span class="line"><span class="keyword">typedef</span> Person PM;</span><br></pre></td></tr></table></figure><p>此时，因为前面有<code>typedef</code>，因此后面本来负责对象定义的地方现在变成了起别名的地方。当然，你在后面继续起也没问题~</p><p>就讲到这了，<del>好吧，这篇文章非常长</del>，初赛考到别懵13哈！</p><hr><p>参考资料（排名不分先后）：</p><ol><li><p><a href="https://blog.csdn.net/weixin_43831728/article/details/107788822">构造函数详解</a></p></li><li><p><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">菜鸟教程——C++教程</a></p></li></ol><p>蒟蒻所写，有问题欢迎私信。</p><p>upd：感谢 <a href="https://www.luogu.com.cn/user/770431">@GavinCQTD</a> 同志帮忙发现了个错别字的bug，已修复</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> “你需要知道的所有”系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C艹 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
